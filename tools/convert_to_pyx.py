"""Simple utility to convert .py files to .pyx copies by adding Cython headers.

This is intentionally conservative: it does not transform Python syntax to Cython
types. It copies file content and prepends a Cython directive header so you can
start from a .pyx copy and iterate manually to add cdef/typed memoryviews, etc.

Usage:
  python tools\convert_to_pyx.py <file1.py> <file2.py> ...
  python tools\convert_to_pyx.py --inplace <dir>   # convert all .py in dir

The script returns non-zero on error.
"""
from __future__ import annotations

import argparse
from pathlib import Path
import sys


CYTHON_HEADER = """# cython: language_level=3
# cython: boundscheck=False, wraparound=False
# Generated by tools/convert_to_pyx.py - review and add explicit types where
# appropriate to get the full performance benefits of Cython.

"""


def convert_file(src: Path, dest: Path) -> None:
    if not src.exists():
        raise FileNotFoundError(src)
    if not src.is_file():
        raise IsADirectoryError(src)

    text = src.read_text(encoding="utf-8")

    # Remove Unix/Windows shebangs from the top when present (not valid in .pyx)
    lines = text.splitlines()
    if lines and lines[0].startswith("#!"):
        lines = lines[1:]
    content = "\n".join(lines) + "\n"

    dest.write_text(CYTHON_HEADER + content, encoding="utf-8")


def find_py_files_in_dir(d: Path):
    for p in sorted(d.iterdir()):
        if p.is_file() and p.suffix == ".py":
            yield p


def main(argv: list[str] | None = None) -> int:
    parser = argparse.ArgumentParser(description="Convert .py files to .pyx copies")
    parser.add_argument("paths", nargs="*", help="Files or directories to convert")
    parser.add_argument("--inplace", action="store_true", help="Write .pyx next to .py files")
    parser.add_argument("--out", type=Path, default=None, help="Output directory for .pyx files")
    parser.add_argument("--overwrite", action="store_true", help="Overwrite existing .pyx files")

    args = parser.parse_args(argv)

    if not args.paths:
        parser.error("At least one file or directory must be provided")

    files_to_convert: list[Path] = []
    for p in args.paths:
        pth = Path(p)
        if pth.is_dir():
            files_to_convert.extend(find_py_files_in_dir(pth))
        else:
            files_to_convert.append(pth)

    if not files_to_convert:
        print("No .py files found to convert.")
        return 1

    out_dir: Path | None = args.out
    if out_dir is not None:
        out_dir = Path(out_dir)
        out_dir.mkdir(parents=True, exist_ok=True)

    failures = 0
    for src in files_to_convert:
        try:
            if src.suffix != ".py":
                print(f"Skipping non-.py file: {src}")
                continue

            if args.inplace:
                dest = src.with_suffix(".pyx")
            elif out_dir is not None:
                dest = out_dir / src.name.replace(".py", ".pyx")
            else:
                # default: write .pyx next to source
                dest = src.with_suffix(".pyx")

            if dest.exists() and not args.overwrite:
                print(f"Skipping existing file (use --overwrite to replace): {dest}")
                continue

            convert_file(src, dest)
            print(f"Wrote: {dest}")
        except Exception as exc:  # pragma: no cover - simple CLI
            print(f"Error converting {src}: {exc}")
            failures += 1

    return 1 if failures else 0


if __name__ == "__main__":
    raise SystemExit(main())
